<!-- TSP template version: move/change blocks show only blank columns + Done button -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Planning Puzzles — TSP Template</title>

  <!-- Load the move and change states (kept for structure; not shown in trials) -->

  <script src="TSP_stimuli_b1.js"></script>
  <script src="TSP_stimuli_b2.js"></script>

  <!-- FileSaver for saving files -->
  <script src="https://cdn.jsdelivr.net/npm/file-saver"></script>

  <!-- JSZip for bundling puzzle logs + audio into one download -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

  <style>
    body {
      font-family: 'Segoe UI', Tahoma, sans-serif;
      background-color: #f9f9f9;
      color: #333;
      margin: 0;
      padding: 20px;
      display: flex;
      justify-content: center;
      flex-direction: column;
      align-items: center;
    }

    .container {
      display: flex;
      flex-wrap: wrap;
      gap: 24px;
      align-items: flex-start;
    }

    .left-column {
      max-width: 420px;
      flex-shrink: 1;
      background-color: #ffffff;
      padding: 16px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
      min-height: 220px; /* keep visible "blank" panel */
    }

    

    .right-column {
      max-width: 700px;
      flex-shrink: 1;
      flex: 2;
      background-color: #ffffff;
      padding: 16px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
      min-height: 220px; /* keep visible "blank" panel */
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }

    .rules-text {
      border-left: 6px solid #42a5f5;
      padding-left: 12px;
      margin-bottom: 20px;
    }

    .state-display { /* retained for non-trial screens */
      font-size: 16px;
      margin: 12px 0;
      background-color: #f4faff;
      padding: 10px 12px;
      border-radius: 6px;
      border-left: 4px solid #42a5f5;
    }

    .done-button {
      font-size: 14px;
      padding: 10px 18px;
      border: none;
      border-radius: 6px;
      background-color: #42a5f5;
      color: white;
      cursor: pointer;
      transition: background-color 0.2s ease;
    }
    .done-button:hover { background-color: #1e88e5; }

    .center { text-align: center; }

    /* Intro, instructions, error, end screens */
    #intro-screen, #instructions-screen, #end-screen {
      max-width: 600px;
      background-color: #ffffff;
      padding: 24px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
      display: none;
    }

    #end-screen { text-align: center; }

    #error-message {
      display: none;
      max-width: 600px;
      color: #B00020;
      background-color: #ffe6e6;
      padding: 12px 16px;
      margin-bottom: 20px;
      border-radius: 8px;
      text-align: center;
      border: 1px solid #F44336;
    }

    /* Add to your <style> */
    .table-matrix {
      border-collapse: collapse;
      margin-top: 12px;
    }
    .table-matrix caption {
      font-weight: 600;
      margin-bottom: 6px;
    }
    .table-matrix th, .table-matrix td {
      border: 1px solid #cfd8dc;
      padding: 6px 8px;
      text-align: center;
    }
    .table-matrix th {
      background: #f4faff;
    }
    .table-matrix .diag {
      color: #9e9e9e;
      background: #fafafa;
    }

  </style>
</head>
<body>

  <!-- Inline error message (replaces native alerts) -->
  <div id="error-message"></div>

  <!-- Container for transient voice prompt banner (inserted dynamically) -->
  <!-- <div id="prompt-message"></div> created by ensurePromptBanner() -->

  <!-- Container for the multi-step intro screens -->
  <div id="intro-screen"></div>

  <!-- Container for per-block instructions -->
  <div id="instructions-screen"></div>

  <!-- The main task UI (blank left/right columns during trials) -->
  <div id="task-ui" class="container" style="display: none;"></div>

  <!-- The final end screen -->
  <div id="end-screen">
    <p style="margin-bottom: 24px; font-size: 18px;">
      The study is now complete.<br>
      Press any key to receive payment.
    </p>
  </div>

  <script type="module">
    // --------------------------------------
    // GLOBAL CONFIG
    // --------------------------------------
    const N = 2; // N problems per block

    // Randomly sample starting states
    function getRandomIndices(len, exclude = [], count = 5) {
      const idxs = [];
      while (idxs.length < count) {
        const i = Math.floor(Math.random() * len);
        if (!idxs.includes(i) && !exclude.includes(i)) idxs.push(i);
      }
      return idxs;
    }

    const moveBlock = Array.from({ length: N }, () => ({}));
    const changeBlock = Array.from({ length: N }, () => ({}));

    // Decide order of blocks randomly
    const blocks = ['move','change'];
    const blockData = { move: moveBlock, change: changeBlock };

    let blockIndex = 0; // which block (0 or 1)
    let trialIndex = 0; // which trial (0..N-1)

    // Build per-block random prompts (N per block) from the correct stimulus set
    const movePrompts   = getRandomIndices(TSP_STIMULI_B1.length, [], N).map(i => TSP_STIMULI_B1[i]);
    const changePrompts = getRandomIndices(TSP_STIMULI_B2.length, [], N).map(i => TSP_STIMULI_B2[i]);
    let currentPrompt = null;
    const promptData = { move: movePrompts, change: changePrompts };

    // puzzle state and logs
    let currentState = {};
    let userActions = [];
    let allProblemLogs = [];


    // participant info
    let participantData = { agreement:'', gender:'', age:'' };

    // problem start timestamp
    let problemStartTime = null;


    // --------------------------------------
    // FIREBASE CONFIGURATION
    // --------------------------------------
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
    import { getFirestore, collection, addDoc, serverTimestamp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';
    import { getStorage, ref, uploadBytes } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-storage.js';

    const firebaseConfig = {
      apiKey: "AIzaSyBmwVKrctSe5uCf_mUk0fX98PU0bfBfZ_k",
      authDomain: "tsp-experiment-storage.firebaseapp.com",
      projectId: "tsp-experiment-storage",
      storageBucket: "tsp-experiment-storage.firebasestorage.app",
      messagingSenderId: "705114542213",
      appId: "1:705114542213:web:c08d81670f40055ff5d9ec",
      measurementId: "G-64EMG37V4C"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const storage = getStorage(app);
    // --------------------------------------
    // HELPERS
    // --------------------------------------

    function showError(msg) {
      const err = document.getElementById('error-message');
      err.textContent = msg;
      err.style.display = 'block';
      setTimeout(() => err.style.display = 'none', 3000);
    }
        
    function renderDistanceTable(hostEl, cities, matrix) {
      const n = cities.length;
      const rowCities = cities.slice(0, n-1); // City 1..4
      const colCities = cities.slice(1);      // City 2..5

      let html = `<table class="table-matrix" aria-label="Upper triangular distances">
        <thead><tr><th></th>${colCities.map(c=>`<th>${c}</th>`).join('')}</tr></thead><tbody>`;

      rowCities.forEach((r, i) => {
        html += `<tr><th scope="row">${r}</th>`;
        colCities.forEach((_, j) => {
          // show only cells on/above the shifted diagonal; dash below it
          html += (j < i)
            ? `<td class="diag">—</td>`
            : `<td>${matrix[i][j+1]}</td>`; // note the +1 offset into full matrix
        });
        html += `</tr>`;
      });

      html += `</tbody></table>`;
      hostEl.insertAdjacentHTML("beforeend", html);
    }

    function readCandidatePathsFromUI() {
      const root = document.getElementById('task-ui');
      if (!root) return [];

      const rows = root.querySelectorAll('#candidate-list .candidate-row');
      const result = [];

      rows.forEach((row, i) => {
        const index = Number(row.dataset.index || i + 1);
        const selects = row.querySelectorAll('.candidate-select');
        const path = Array.from(selects, s => (s.value || ""));

        // distance input is created as "...-distance" per row
        const distEl = row.querySelector("input[id$='-distance']");
        const totalDistance = distEl && distEl.value ? Number(distEl.value) : null;

        // keep rows that have at least some content (path and/or distance)
        if (path.some(v => v !== "") || totalDistance !== null) {
          result.push({ index, path, totalDistance });
        }
      });

      return result;
    }

    function readFinalPathFromUI() {
      const root = document.getElementById('task-ui');
      const selects = root ? root.querySelectorAll('.final-select') : [];
      const path = Array.from(selects, s => s.value).filter(Boolean);
      const distEl = root ? root.querySelector('#total-distance') : null;
      const totalDistance = distEl && distEl.value ? Number(distEl.value) : null;
      return { path, totalDistance };
    }

    // --------------------------------------
    // AUDIO RECORDING
    // --------------------------------------
    let audioStream = null;
    let recorder = null;
    const audioChunks = []; // {block, trial, blob}

    async function requestAudioPermission() {
      try {
        audioStream = await navigator.mediaDevices.getUserMedia({ audio:true });
      } catch (e) {
        console.error(e);
        showError("Microphone access is needed to record your responses.");
      }
    }

    function startRecording(blockNum, trialNum) {
      if (!audioStream) return;
      recorder = new MediaRecorder(audioStream);
      recorder.ondataavailable = e => {
        if (e.data.size > 0) audioChunks.push({ block:blockNum, trial:trialNum, blob:e.data });
      };
      recorder.start();
    }

    function stopRecording(cb) {
      if (!recorder) { cb && cb(); return; }
      recorder.onstop = () => { cb && cb(); };
      recorder.stop();
      recorder = null;
    }

    // =============================
    // LIVE VOICE FEEDBACK MODULE (separate from saving recorder)

    function ensurePromptBanner() {
      let el = document.getElementById("prompt-message");
      if (!el) {
        el = document.createElement("div");
        el.id = "prompt-message";
        el.style.display = "none";
        el.style.maxWidth = "600px";
        el.style.margin = "0 0 20px 0";
        el.style.background = "#E3F2FD"; // light blue
        el.style.color = "#0D47A1";      // dark blue text
        el.style.border = "1px solid #90CAF9";
        el.style.borderRadius = "8px";
        el.style.padding = "12px 16px";
        el.style.textAlign = "center";
        const anchor = document.querySelector('#error-message');
        (anchor?.parentNode || document.body).insertBefore(el, anchor?.nextSibling || null);
      }
      return el;
    }

    function showPrompt(msg, ms = 4000) {
      const el = ensurePromptBanner();
      el.textContent = msg;
      el.style.display = "block";
      clearTimeout(showPrompt._t);
      showPrompt._t = setTimeout(() => (el.style.display = "none"), ms);
    }

    // ---- Live voice feedback using Web Audio API AnalyserNode ----
    const VoiceFeedback = (() => {
      let ctx = null;
      let source = null;
      let analyser = null;
      let freqData = null;
      let running = false;
      let timer = null;

      const cfg = {
        intervalSec: 20,   // check cadence (seconds)
        threshold: .0008,  // tune after pilot
        minHz: 85,
        maxHz: 255,
        fftSize: 2048,
        smoothing: 0.8,
      };

      let accum = 0;   // accumulated average over frames
      let frames = 0;  // number of frames accumulated
      let minBin = 0, maxBin = 0;

      function setupBins(sampleRate, fftSize) {
        const binHz = sampleRate / fftSize;
        minBin = Math.floor(cfg.minHz / binHz);
        maxBin = Math.ceil(cfg.maxHz / binHz);
      }

      function sampleLoop() {
        if (!running) return;
        analyser.getFloatFrequencyData(freqData); // dB values
        // Convert dB to linear magnitude and average over the speech band
        let total = 0;
        for (let i = minBin; i <= maxBin && i < freqData.length; i++) {
          total += Math.pow(10, freqData[i] / 20);
        }
        const avg = total / Math.max(1, (maxBin - minBin + 1));
        accum += avg;
        frames += 1;
        requestAnimationFrame(sampleLoop);
      }

      async function start() {
        if (running) return;
        if (!audioStream) return; // mic not granted yet
        ctx = new (window.AudioContext || window.webkitAudioContext)();
        await ctx.resume().catch(()=>{});
        source = ctx.createMediaStreamSource(audioStream);

        analyser = ctx.createAnalyser();
        analyser.fftSize = cfg.fftSize;
        analyser.smoothingTimeConstant = cfg.smoothing;

        freqData = new Float32Array(analyser.frequencyBinCount);
        source.connect(analyser);

        setupBins(ctx.sampleRate, analyser.fftSize);
        accum = 0; frames = 0; running = true;
        sampleLoop();

        timer = setInterval(() => {
          if (!running) return;
          const avgActivity = frames ? (accum / frames) : 0;
          if (avgActivity < cfg.threshold) {
            showPrompt("Please keep speaking your thoughts aloud.");
          }
          console.debug('avgActivity', avgActivity.toFixed(5));
          accum = 0; frames = 0; // reset window
        }, cfg.intervalSec * 1000);
      }

      async function stop() {
        running = false;
        clearInterval(timer);
        try { source && source.disconnect(); } catch (_) {}
        try { ctx && (await ctx.close()); } catch (_) {}
        ctx = source = analyser = null;
        freqData = null;
        accum = 0; frames = 0;
      }

      function setConfig(overrides) { Object.assign(cfg, overrides || {}); }
      return { start, stop, setConfig, cfg };
    })();


    // --------------------------------------
    // INTRO SCREENS
    // --------------------------------------
    let introIndex = 0;
    const introScreens = [
      // 0
      `
        <p>In this study, you will solve problems involving identifying the shortest path between cities.</p>
        <p>Only anonymous data without any personal information will be stored for research purposes.</p>
        <p>Audio will also be recorded while you solve the problems.</p>
        <p>The whole study will take no longer than 1 hour to complete.</p>
        <p>If you agree to participate in the study, please respond by typing something in the box provided below.</p>
        <p>Otherwise, please close the study window.</p>
        <p><input type="text" id="agreeInput" style="width: 95%;" placeholder="Type your response here..."></p>
      `,
      // 1
      `
        <p>Please provide the following information.</p>
        <p>Gender:</p>
        <p>
          <select id="genderSelect" style="width: 100%;">
            <option value="" disabled selected hidden>Select...</option>
            <option value="Male">Male</option>
            <option value="Female">Female</option>
            <option value="Nonbinary">Nonbinary</option>
            <option value="Other">Other (please specify)</option>
          </select>
        </p>
        <p id="otherGenderWrapper" style="display:none;">
          <input type="text" id="otherGenderInput" style="width: 95%;" placeholder="Please specify..." />
        </p>
        <p>Age:</p>
        <p><input type="number" id="ageInput" style="width: 95%;" placeholder="Type your age here..." /></p>
      `,
      // 2
      `
        <p>Please turn off any music or potential sources of distraction.</p>
        <p>The experiment will switch to full screen mode when you press the button below.</p>
        <p>Please remain in full screen mode until the experiment is complete.</p>
        <p>Microphone access will also be requested for audio recording.</p>
      `,
      // 3
      `
        <p>The experiment will consist of two blocks with the same types of problems. Each block will contain ${N} problems.</p>
        <p>Before the first block, you will be presented with instructions.</p>
        <p>You will have a brief period to rest in between the first and second blocks.</p>
        <p>Please press 'Next' to see the instructions for Block #1.</p>
      `
    ];

    function startIntro() {
      introIndex = 0;
      showIntroScreen();
    }

    function showIntroScreen() {
      const introDiv = document.getElementById('intro-screen');
      introDiv.innerHTML = introScreens[introIndex] + `
        <div style="text-align: center; margin-top: 24px;">
          <button id="introNextBtn" style="padding: 10px 20px;">Next</button>
        </div>
      `;
      introDiv.style.display = 'block';

      document.getElementById('introNextBtn').addEventListener('click', handleIntroNext);

      if (introIndex === 1) {
        const sel = document.getElementById('genderSelect');
        sel.addEventListener('change', () => {
          document.getElementById('otherGenderWrapper').style.display =
            sel.value === 'Other' ? 'block' : 'none';
        });
      }
    }

    async function handleIntroNext() {
      if (introIndex === 0) {
        const val = document.getElementById('agreeInput').value.trim();
        if (!val) { showError("Please type something to proceed."); return; }
        participantData.agreement = val;

      } else if (introIndex === 1) {
        const gSel = document.getElementById('genderSelect');
        const age = document.getElementById('ageInput').value.trim();
        if (!gSel.value || !age) {
          showError("Please select a gender and enter your age."); return; }
        if (gSel.value === 'Other') {
          const spec = document.getElementById('otherGenderInput').value.trim();
          if (!spec) { showError("Please specify your gender."); return; }
          participantData.gender = spec;
        } else {
          participantData.gender = gSel.value;
        }
        participantData.age = age;

      } else if (introIndex === 2) {
        if (document.body.requestFullscreen) document.body.requestFullscreen();
        else if (document.documentElement.requestFullscreen) document.documentElement.requestFullscreen();
        await requestAudioPermission();
      }

      introIndex++;
      if (introIndex < introScreens.length) {
        showIntroScreen();
      } else {
        document.getElementById('intro-screen').style.display = 'none';
        loadBlock();
      }
    }

    // --------------------------------------
    // PER-BLOCK INSTRUCTIONS
    // --------------------------------------
    function loadBlock() {
      const blockNum = blockIndex + 1;
      const blockType = blocks[blockIndex];
      if (blockType === 'move') showMoveInstructions(blockNum);
      else showChangeInstructions(blockNum);
    }

    function showMoveInstructions(blockNumber) {
      const inst = document.getElementById('instructions-screen');
      inst.style.display = 'block';
      inst.innerHTML = `
        <h2>Experiment Instructions (for both blocks)</h2>
        <p>In this experiment, you will be presented with sets of cities and their distances. Your goal is to find the shortest possible route that visits each city exactly once and returns to the original city.</p>

        <p style="font-size:1.15rem;"><strong>Importantly, as you are solving the problems, try to say out loud everything that goes through your mind.</strong></p>
        <p style="font-size:1.15rem;"><strong>If you are silent for a long period of time, we will send you a reminder to speak your thoughts aloud.</strong></p>

        <p>There will be ${N} problems in each block.</p>
        <div style="text-align:center;margin-top:24px;">
          <button id="begin-block-btn" style="padding:10px 20px;">Continue to Practice Trial</button>
        </div>
      `;
      document.getElementById('begin-block-btn').addEventListener('click', () => {
        showMoveRuleCheck(blockNumber);
      });
    }

    // Rule check (retained)
    function showMoveRuleCheck(blockNumber) {
      // Hide the instructions panel and show the main task container
      const inst = document.getElementById('instructions-screen');
      inst.style.display = 'none';

      const container = document.getElementById('task-ui');
      container.style.display = 'flex';

      // Left-column text (practice-specific)
      const leftHTML = `
        <div class="rules-text">
          <h3>Example Trial (Practice)</h3>
          <p>Read the Instructions below and practice creating paths using the drop-down menus as you search for the shortest route.</p>
          <h3>Instructions</h3>
          <p>Your goal is to find the shortest possible route that visits each city exactly once and returns to the original city.</p>
          <p>Report the shortest path by selecting cities from drop-down menus and enter the total distance in a text box. You may change the order of your answer after selecting a city if necessary.</p>
          <p> As you solve a problem, you will also be able to create Candidate Paths using drop-down menus. When you add cities to Candidate Paths and the Final Path during the experiment, please continue to speak your thoughts aloud.</p>
          <p>When you feel comfortable with the controls and have selected cities and the total distance for the Final Path, press <strong>Continue</strong> to begin the experiment.</p>
        </div>
      `;

      // Shared options (same as the experimental blocks)
      const cityOptions = ['City 1','City 2','City 3','City 4']
        .map(c => `<option value="${c}">${c}</option>`).join('');
      const blank = `<option value="" selected disabled hidden></option>`;

      // Candidate Paths section
      const candidateSectionHTML = `
        <div id="candidate-section" class="candidate-section" style="margin-bottom:16px;">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; font-weight:600;">
            <h4 style="margin:0;">Candidate Paths</h4>
            <button id="add-candidate" type="button" class="add-candidate">+ Click to add Candidate Path</button>
          </div>
          <div id="candidate-list" class="candidate-list" style="display:flex; flex-direction:column; gap:8px;"></div>
        </div>
      `;

      // Final Path section
      const finalPathHTML = `
        <div class="final-path" style="margin-bottom:14px;">
          <label class="final-path-label" for="final-1" style="display:block; margin-bottom:8px; font-weight:600;">
            <h4 style="margin:0;">Final Path (click to select cities)</h4>
          </label>
          <div class="dropdown-row" style="display:flex; gap:12px; align-items:center;">
            <select id="final-1" class="final-select">${blank}${cityOptions}</select>
            <select id="final-2" class="final-select">${blank}${cityOptions}</select>
            <select id="final-3" class="final-select">${blank}${cityOptions}</select>
            <select id="final-4" class="final-select">${blank}${cityOptions}</select>
            <select id="final-5" class="final-select">${blank}${cityOptions}</select>

            <!-- NEW: Total Distance (positive integers only) -->
            <div id="total-distance-wrap"
                style="display:flex; align-items:center; gap:6px; margin-left:auto;">
              <label for="total-distance" style="font-weight:600;">Total Distance</label>
              <input id="total-distance"
                    inputmode="numeric"
                    pattern="[1-9][0-9]*"
                    aria-label="Total Distance (positive integer only)"
                    placeholder="e.g., 30"
                    style="width:100px; padding:6px 8px;" />
            </div>
          </div>
        </div>
      `;

      // Lay out the two columns just like the experimental blocks
      container.innerHTML = `
        <div class="left-column">${leftHTML}</div>
        <div class="right-column">
          ${candidateSectionHTML}
          ${finalPathHTML}
          <div id="completion-warning" style="margin:8px 0; font-size:0.9rem; color:#b00020;"></div>
          <div class="center">
            <button id="move-check-continue-btn" class="done-button" disabled>Continue (Begin Experiment)</button>
          </div>
        </div>
      `;

      // Practice distance matrix (4 cities), rendered like the trial tables
      const practiceCities = ['City 1', 'City 2', 'City 3', 'City 4'];
      const practiceMatrix = [
        [0, 9, 6, 4],
        [9, 0, 7, 3],
        [6, 7, 0, 2],
        [4, 3, 2, 0],
      ];

      // Append under the left-column instructions
      const leftCol = container.querySelector('.left-column');
      const host = document.createElement('div');
      host.id = 'practice-distance-table';
      host.style.marginTop = '12px';

      const title = document.createElement('h4');
      title.textContent = 'Distances Between Cities:';
      title.style.margin = '0 0 8px 0';   // match styling of other section titles
      leftCol.appendChild(title);

      leftCol.appendChild(host);

      // Uses the same formatting/indexing as move/change blocks
      renderDistanceTable(host, practiceCities, practiceMatrix);

      const practiceFinalDist = container.querySelector('#total-distance');
      if (practiceFinalDist) {
        practiceFinalDist.addEventListener('keypress', (e) => {
          if (!/[0-9]/.test(e.key)) e.preventDefault();
        });
        practiceFinalDist.addEventListener('input', (e) => {
          e.target.value = e.target.value.replace(/[^\d]/g, '').replace(/^0+/, '');
        });
      }

      // ---------- Candidate Paths logic (same behavior as trials) ----------
      const list = container.querySelector('#candidate-list');
      let candidateCount = 0;

      function addCandidatePath() {
        candidateCount += 1;
        const row = document.createElement('div');
        row.className = 'candidate-row';
        row.dataset.index = String(candidateCount);
        row.style.display = 'flex';
        row.style.gap = '12px';
        row.style.alignItems = 'center';

        row.innerHTML = `
          <div class="dropdown-row" style="display:flex; gap:12px; align-items:center; width:100%;">
            <select class="candidate-select" id="cand-${candidateCount}-1">${blank}${cityOptions}</select>
            <select class="candidate-select" id="cand-${candidateCount}-2">${blank}${cityOptions}</select>
            <select class="candidate-select" id="cand-${candidateCount}-3">${blank}${cityOptions}</select>
            <select class="candidate-select" id="cand-${candidateCount}-4">${blank}${cityOptions}</select>
            <select class="candidate-select" id="cand-${candidateCount}-5">${blank}${cityOptions}</select>


            <!-- NEW: per-candidate Total Distance -->
            <div class="cand-distance-wrap" style="display:flex; align-items:center; gap:6px; margin-left:auto;">
              <label for="cand-${candidateCount}-distance" style="font-weight:600;">Total Distance</label>
              <input id="cand-${candidateCount}-distance"
                    inputmode="numeric"
                    pattern="[1-9][0-9]*"
                    aria-label="Candidate Total Distance (positive integer only)"
                    placeholder="e.g., 30"
                    style="width:100px; padding:6px 8px;" />
            </div>
          </div>
        `;
        list.appendChild(row);

        const candDist = row.querySelector(`#cand-${candidateCount}-distance`);
        if (candDist) {
          candDist.addEventListener('keypress', (e) => { if (!/[0-9]/.test(e.key)) e.preventDefault(); });
          candDist.addEventListener('input', (e) => {
            e.target.value = e.target.value.replace(/[^\d]/g, '').replace(/^0+/, '');
          });
}

      }

      container.querySelector('#add-candidate').addEventListener('click', addCandidatePath);
      // Start with one candidate row
      addCandidatePath();

      // ---------- Gating for Continue (mirrors "Done" in trials) ----------
      function allSelected() {
        return Array.from(container.querySelectorAll('.final-select'))
          .every(s => s.value && s.value !== '');
      }
      function updateContinueState() {
        const ok = allSelected();
        container.querySelector('#move-check-continue-btn').disabled = !ok;
        container.querySelector('#completion-warning').textContent = '';
      }
      container.querySelectorAll('.final-select')
        .forEach(s => s.addEventListener('change', updateContinueState));
      updateContinueState();

      // Continue into the real block
      container.querySelector('#move-check-continue-btn').addEventListener('click', () => {
        container.style.display = 'none';
        startBlock(); // this begins the actual trials as before
      });
    }

    function showChangeInstructions(blockNumber) {
      const inst = document.getElementById('instructions-screen');
      inst.style.display = 'block';
      inst.innerHTML = `
        <h2>Please take a brief rest before continuing to Block #${blockNumber}</h2>
        <p>In this block, you will continue solving shortest-path style problems.</p>
        <p>As you solve the problems, please continue to describe your thought process out loud.</p>
        <p>There will be ${N} problems in this block.</p>
        <div style="text-align:center;margin-top:24px;">
          <button id="begin-block-btn" style="padding:10px 20px;">Begin block</button>
        </div>
      `;
      document.getElementById('begin-block-btn').addEventListener('click', () => {
        inst.style.display = 'none';
        startBlock();
      });
    }

    // --------------------------------------
    // BLOCK & TRIAL FLOW
    // --------------------------------------
    function startBlock() {
      trialIndex = 0;
      document.getElementById('task-ui').style.display = 'flex';
      loadTrial();
    }

    function loadTrial() {
      const blockNum = blockIndex + 1;
      const problemNum = trialIndex + 1;
      const type = blocks[blockIndex];
      currentPrompt = (type === 'move' ? movePrompts : changePrompts)[trialIndex];
      currentState = structuredClone(blockData[type][trialIndex]);
      userActions = [];
      problemStartTime = Date.now();
      startRecording(blockNum, problemNum);
      VoiceFeedback.start();
      renderUI(type);
    }

    // --------------------------------------
    // RENDERING — MOVE/CHANGE BLOCKS
    // --------------------------------------
    function renderUI(type) {
    const container = document.getElementById('task-ui');

    // Left column instructions (unchanged)
    // Left column = instructions + the selected problem prompt (HTML)
    const instructionsHTML = `
      <div class="rules-text">
        <h3>Instructions</h3>
        <p>Your goal is to find the shortest possible route that visits each city exactly once and returns to the original city.</p>
        <p>Report the shortest path by selecting cities from drop-down menus and enter the total distance in a text box. You may change the order of your answer after selecting a city if necessary.</p>
      </div>
      <div id="problem-prompt" style="margin-top:12px;">${currentPrompt?.prompt || ''}
      </div>
    `;

    // Shared options (use stimulus cities if present; default to 5)
    const cities = currentPrompt?.cities || ['City 1','City 2','City 3','City 4','City 5'];
    const cityOptions = cities.map(c => `<option value="${c}">${c}</option>`).join('');

    const blank = `<option value="" selected disabled hidden></option>`;


    // How many cities in this problem (prefer matrix rows, fallback to cities list)
    // Need N + 1 dropdowns to return to the start city
    const numCities = cities.length;
    // Need N + 1 dropdowns to return to the start city
    const numStops = numCities + 1;

    // Small helper to render a run of <select> elements
    function renderPathSelects(prefix, cssClass, count) {
      return Array.from({ length: count }, (_, i) =>
        `<select id="${prefix}-${i + 1}" class="${cssClass}">${blank}${cityOptions}</select>`
      ).join('');
    }

    // Candidate Paths section + button
    const candidateSectionHTML = `
      <div id="candidate-section" class="candidate-section" style="margin-bottom:16px;">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
          <h4 style="margin:0;">Candidate Paths</h4>
          <button id="add-candidate" type="button" class="add-candidate">+ Click to add Candidate Path</button>
        </div>
        <div id="candidate-list" class="candidate-list" style="display:flex; flex-direction:column; gap:8px;"></div>
      </div>
    `;

    // Final Path (note class final-select so gating only checks these)
    const finalPathHTML = `
      <div class="final-path" style="margin-bottom:14px;">
        <label class="final-path-label" for="final-1" style="display:block; margin-bottom:8px; font-weight:600;">
          <h4 style="margin:0;">Final Path (click to select cities)</h4>
        </label>
        <div class="dropdown-row" style="display:flex; gap:12px; align-items:center;">
          ${renderPathSelects('final', 'final-select', numStops)}

          <!-- NEW: Total Distance input (positive integers only) -->
          <div id="total-distance-wrap"
              style="display:flex; align-items:center; gap:6px; margin-left:auto;">
            <label for="total-distance" style="font-weight:600;">Total Distance</label>
            <input id="total-distance"
                  name="total-distance"
                  inputmode="numeric"
                  pattern="[1-9][0-9]*"
                  aria-label="Total Distance (positive integer only)"
                  placeholder="e.g., 30"
                  style="width:100px; padding:6px 8px;" />
          </div>
        </div>
      </div>
    `;

    // Render columns
    container.innerHTML = `
      <div class="left-column">${instructionsHTML}</div>
      <div class="right-column">
        ${candidateSectionHTML}
        ${finalPathHTML}
        <div id="completion-warning" style="margin:8px 0; font-size:0.9rem; color:#b00020;"></div>
        <div class="center">
          <button id="done-button" class="done-button" disabled>Done</button>
        </div>
      </div>
    `;

    // Append distance table under the prompt text (left column)
    const promptEl = container.querySelector('#problem-prompt');
    if (promptEl && currentPrompt?.matrix) {
      renderDistanceTable(promptEl, cities, currentPrompt.matrix);
    }


    // ---------- Final Path gating (only checks .final-select) ----------
    function allSelected() {
      const pathOk = Array.from(container.querySelectorAll('.final-select'))
        .every(s => s.value && s.value !== '');
      const dist = container.querySelector('#total-distance');
      const distOk = dist ? /^[1-9]\d*$/.test(dist.value.trim()) : true;
      return pathOk && distOk;
    }

    function updateDoneState() {
      const ok = allSelected();
      container.querySelector('#done-button').disabled = !ok;
      container.querySelector('#completion-warning').textContent = ''; // no text
    }
    container.querySelector('#done-button').addEventListener('click', endTrial);
    container.querySelectorAll('.final-select')
      .forEach(s => s.addEventListener('change', updateDoneState));
    updateDoneState();

    const distInput = container.querySelector('#total-distance');
    if (distInput) {
      ['input','change'].forEach(evt =>
        distInput.addEventListener(evt, updateDoneState)
      );
    }

    if (distInput) {
      // Block non-digits on keypress
      distInput.addEventListener('keypress', (e) => {
        if (!/[0-9]/.test(e.key)) e.preventDefault();
      });
      // Sanitize pasted/edited text; remove non-digits & leading zeros
      distInput.addEventListener('input', (e) => {
        e.target.value = e.target.value.replace(/[^\d]/g, '').replace(/^0+/, '');
        updateDoneState();
      });
    }

    
    // ---------- Candidate Paths logic ----------
    const list = container.querySelector('#candidate-list');
    let candidateCount = 0;

    function addCandidatePath() {
      candidateCount += 1;
      const row = document.createElement('div');
      row.className = 'candidate-row';
      row.dataset.index = String(candidateCount);
      row.style.display = 'flex';
      row.style.gap = '12px';
      row.style.alignItems = 'center';

      row.innerHTML = `
        <div class="dropdown-row" style="display:flex; gap:12px; align-items:center; width:100%;">
          ${renderPathSelects(`cand-${candidateCount}`, 'candidate-select', numStops)}
          <div class="cand-distance-wrap" style="display:flex; align-items:center; gap:6px; margin-left:auto;">
            <label for="cand-${candidateCount}-distance" style="font-weight:600;">Total Distance</label>
            <input id="cand-${candidateCount}-distance"
                  inputmode="numeric"
                  pattern="[1-9][0-9]*"
                  aria-label="Candidate Total Distance (positive integer only)"
                  placeholder="e.g. 30"
                  style="width:100px; padding:6px 8px;" />
          </div>
        </div>
      `;

      list.appendChild(row);
      const candDist = row.querySelector(`#cand-${candidateCount}-distance`);
      if (candDist) {
        candDist.addEventListener('keypress', (e) => { if (!/[0-9]/.test(e.key)) e.preventDefault(); });
        candDist.addEventListener('input', (e) => {
          e.target.value = e.target.value.replace(/[^\d]/g, '').replace(/^0+/, '');
        });
      }
    }

    container.querySelector('#add-candidate').addEventListener('click', addCandidatePath);

    // Initial candidate path row
    addCandidatePath();
  }

    // --------------------------------------
    // END OF TRIAL / BLOCK / STUDY
    // --------------------------------------
    function endTrial() {
      stopRecording(async () => {
        await VoiceFeedback.stop();

        readCandidatePathsFromUI().forEach(c => {
          userActions.push({
            type: 'candidate-path',
            index: c.index,           // 1-based row number shown to the participant
            path: c.path,             // e.g., ["City 3","City 5","City 1","City 2","City 4","City 3"]
            totalDistance: c.totalDistance, // number or null
            capturedAt: Date.now()
          });
        });

        const { path, totalDistance } = readFinalPathFromUI();
        userActions.push({
          type: 'final-path',
          path,              // e.g., ["City 3","City 5","City 1","City 2","City 4","City 3"]
          totalDistance,     // number or null if not entered
          capturedAt: Date.now()
        });

        const type = blocks[blockIndex];
        allProblemLogs.push({
          blockType: type,
          trialIndex: trialIndex + 1,
          promptId: currentPrompt?.id || null,
          actions: userActions,
          startTime: problemStartTime,
          endTime: Date.now()
        });

        trialIndex++;
        if (trialIndex < N) loadTrial();
        else {
          blockIndex++;
          if (blockIndex < 2) {
            document.getElementById('task-ui').style.display = 'none';
            loadBlock();
          } else {
            finishStudy();
          }
        }
      });
    }

    async function finishStudy() {
      if (document.fullscreenElement) document.exitFullscreen().catch(()=>{});
      document.getElementById('task-ui').style.display = 'none';

      const end = document.getElementById('end-screen');
      const puzzleData = { participantData, puzzleLogs: allProblemLogs };
      const timestamp = Date.now();
      const participantId = `P_${timestamp}_${Math.random().toString(36).substr(2, 9)}`;

      try {
        // Save to Firebase
        try {
          // 1. Upload audio files to Storage
          for (const {block, trial, blob} of audioChunks) {
            const audioFileName = `audio/${participantId}/block${block}_problem${trial}.webm`;
            const audioRef = ref(storage, audioFileName);
            await uploadBytes(audioRef, blob);
          }

          // 2. Save experiment data to Firestore
          const experimentData = {
            participantId,
            timestamp: serverTimestamp(),
            clientTimestamp: timestamp,
            participantData,
            puzzleLogs: allProblemLogs,
            audioFileCount: audioChunks.length,
            userAgent: navigator.userAgent
          };

          const docRef = await addDoc(collection(db, 'experiments'), experimentData);
          console.log('Data saved to Firebase with ID:', docRef.id);

        } catch (firebaseError) {
          console.error('Firebase save failed:', firebaseError);
          showError('Could not save to Firebase; will save locally instead.');
        }

        // Always create local ZIP as backup
        const zip = new JSZip();
        zip.file("puzzle_data.json", JSON.stringify(puzzleData, null, 2));
        audioChunks.forEach(({ block, trial, blob }) => {
          zip.file(`block${block}_problem${trial}.webm`, blob);
        });
        const zipBlob = await zip.generateAsync({ type: "blob" });
        saveAs(zipBlob, "combined_task_data_with_audio.zip");

      } catch (err) {
        console.error('Error in finishStudy:', err);
        showError('Some data saving failed, but study is complete.');
      } finally {
        // Always show end screen
        end.style.display = 'block';
        end.setAttribute('tabindex', '-1');
        end.focus();
        document.addEventListener('keydown', onEndScreenKey, { once: true });
      }
    }

    // Replace your onEndScreenKey with this version
    function onEndScreenKey() {
      document.removeEventListener('keydown', onEndScreenKey);
      const end = document.getElementById('end-screen');
      end.innerHTML = `
        <p style="margin-bottom:16px; font-size:18px;">
          User pressed a key on end screen—trigger payment logic here!
        </p>
        <p style="font-size:14px; opacity:.8;">
          (This is where you’d redirect to your completion URL or call your payment API.)
        </p>
      `;
      // e.g. window.location.href = 'https://your-completion-url';
    }

    // --------------------------------------
    // START
    // --------------------------------------
    startIntro();
  </script>
</body>
</html>